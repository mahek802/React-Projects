(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('chart.js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'chart.js'], factory) :
  (factory((global.lineHeightAnnotationPlugin = {}),global.Chart));
}(this, (function (exports,Chart) { 'use strict';

  Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /**
   * @name AnnotationRenderer
   * AnnotationRenderer is responsible for affecting changes on the canvas.
   * It handles styling options and drawing from context. It takes in context
   * and the options from the chart config.
   * @param ctx context from chart.ctx
   * @param options options from chart.config.option.lineHeightAnnotation
   */

  var AnnotationRenderer =
  /*#__PURE__*/
  function () {
    function AnnotationRenderer(ctx, options) {
      _classCallCheck(this, AnnotationRenderer);

      this.ctx = ctx;
      this.options = options;
    }
    /**
     * Add shadow on the line from options. Affects all lines on canvas.
     * Shadow Options: shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY.
     */


    _createClass(AnnotationRenderer, [{
      key: "shadow",
      value: function shadow() {
        var options = this.options;

        if (options.shadow) {
          var ctx = this.ctx;
          var shadow = options.shadow;
          var _stroke = ctx.stroke;

          ctx.stroke = function () {
            ctx.save();
            ctx.shadowColor = shadow.color ? shadow.color : "rgba(0,0,0,0.35)";
            ctx.shadowBlur = shadow.blur ? shadow.blur : 10;
            ctx.shadowOffsetX = shadow.offset ? shadow.offset.x : 0;
            ctx.shadowOffsetY = shadow.offset ? shadow.offset.y : 3;

            _stroke.apply(this, arguments);

            ctx.restore();
          };
        }
      }
      /**
       * Draw the line height annotation to the highest data point on the chart.
       * @param {int} x horizontal coordinate on canvas
       * @param {int} bottomY bottom Y dimension of the chart
       * @param {float} highestDataY highest possible Y value on the chart, taking padding and border offsets into consideration.
       */

    }, {
      key: "drawLineHeightAnnotation",
      value: function drawLineHeightAnnotation(x, bottomY, highestDataY) {
        var ctx = this.ctx;
        var options = this.options;
        ctx.save();
        ctx.beginPath();

        if (!options.noDash) {
          ctx.setLineDash([10, 10]);
        }

        ctx.moveTo(x, highestDataY);
        ctx.lineTo(x, bottomY);
        ctx.lineWidth = options.lineWeight ? options.lineWeight : 1.5;
        ctx.strokeStyle = options.color ? options.color : "#000";
        ctx.stroke();
        ctx.restore();
      }
    }]);

    return AnnotationRenderer;
  }();
  /**
   * @name LineChartUtils
   * LineChartUtils calculates metrics about the chart for annotations.
   * @param chart chartjs instance
   */

  var LineChartUtils =
  /*#__PURE__*/
  function () {
    function LineChartUtils(chart) {
      _classCallCheck(this, LineChartUtils);

      this.chart = chart;
    }
    /**
     * calculate the highest possible Y value to draw the line to
     * @param {array} pointMetrics array of dimensions
     */


    _createClass(LineChartUtils, [{
      key: "calculateHighestDataY",
      value: function calculateHighestDataY(pointMetrics) {
        var _pointMetrics = _slicedToArray(pointMetrics, 6),
            bottomY = _pointMetrics[0],
            topY = _pointMetrics[1],
            maxY = _pointMetrics[2],
            tickMax = _pointMetrics[3],
            tickLow = _pointMetrics[4],
            borderWidth = _pointMetrics[5];

        var yBRatio = bottomY * (maxY - tickLow);
        var tMRatio = yBRatio / (tickMax - tickLow);
        return bottomY - tMRatio + borderWidth * 2 + topY - 9;
      }
    }, {
      key: "isTooltipActive",
      value: function isTooltipActive() {
        return this.tooltip._active && this.tooltip._active.length;
      }
    }, {
      key: "isPointTooHigh",
      value: function isPointTooHigh(highestDataY, bottomY, tickLow) {
        if (highestDataY > bottomY) {
          highestDataY = bottomY - tickLow;
        }

        return highestDataY;
      }
    }, {
      key: "getPointFromDataset",
      value: function getPointFromDataset(set, activePoint) {
        return set.data[activePoint._index].y ? set.data[activePoint._index].y : set.data[activePoint._index];
      }
    }, {
      key: "getPointMetrics",
      value: function getPointMetrics(set, point, pointProps) {
        var _pointProps = _slicedToArray(pointProps, 2),
            maxY = _pointProps[0],
            borderWidth = _pointProps[1];

        if (point > maxY) {
          if (set.borderWidth) {
            borderWidth = set.borderWidth;
            maxY = point - borderWidth;
          } else {
            maxY = point;
          }
        }

        return [maxY, borderWidth];
      }
    }, {
      key: "getMaximumDimensions",
      value: function getMaximumDimensions(axis) {
        if (axis.ticksAsNumbers) {
          var _tickMax = axis.ticksAsNumbers[0]; // first index is always the tallest

          var _tickLow = axis.ticksAsNumbers[axis.ticksAsNumbers.length - 1]; // lowest tick

          var _top = axis.top,
              _bottom = axis.bottom;
          return [_tickMax, _tickLow, _top, _bottom];
        }

        var tickLow = Number(axis.ticks[0]);
        var tickMax = Number(axis.ticks[axis.ticks.length - 1]);
        var top = axis.top,
            bottom = axis.bottom;
        return [tickMax, tickLow, top, bottom];
      }
    }, {
      key: "options",
      get: function get() {
        return this.chart.options.lineHeightAnnotation ? this.chart.options.lineHeightAnnotation : false;
      }
    }, {
      key: "tooltip",
      get: function get() {
        return this.chart.tooltip;
      }
    }, {
      key: "datasets",
      get: function get() {
        return this.chart.config.data.datasets;
      }
    }, {
      key: "ticks",
      get: function get() {
        return this.chart.scales["x-axis-0"].ticks;
      }
    }, {
      key: "chartArea",
      get: function get() {
        return this.chart.chartArea;
      }
    }]);

    return LineChartUtils;
  }();
  var plugin = {
    id: "lineHeightAnnotation",
    afterDatasetDraw: function afterDatasetDraw(chart) {
      var lineChartUtils = new LineChartUtils(chart);
      var options = lineChartUtils.options;
      var ctx = chart.ctx;
      var optionsHandler = new AnnotationRenderer(ctx, options);
      optionsHandler.shadow();
      var xAxis = chart.scales[options.xAxis ? options.xAxis : "x-axis-0"];
      var yAxis = chart.scales[options.yAxis ? options.yAxis : "y-axis-0"]; // Activity pages don't need this functionality.

      if (!yAxis) {
        return;
      }

      if (!xAxis) {
        return;
      }

      var _lineChartUtils$getMa = lineChartUtils.getMaximumDimensions(yAxis),
          _lineChartUtils$getMa2 = _slicedToArray(_lineChartUtils$getMa, 4),
          tickMax = _lineChartUtils$getMa2[0],
          tickLow = _lineChartUtils$getMa2[1],
          topY = _lineChartUtils$getMa2[2],
          bottomY = _lineChartUtils$getMa2[3];

      var datasets = lineChartUtils.datasets;
      var meta = [];
      var always = options.always === undefined ? true : options.always;

      if (always) {
        datasets.forEach(function (set, i) {
          meta.push(chart.getDatasetMeta(i).data);
        });
        var ticks = lineChartUtils.ticks;

        var _loop = function _loop(k) {
          var xSpace = xAxis.getPixelForTick(k);
          meta.map(function (set) {
            var points = set.filter(function (point) {
              return point._model.x === xSpace;
            });
            points.forEach(function (point) {
              optionsHandler.drawLineHeightAnnotation(xSpace, bottomY, point._model.y);
            });
          });
        };

        for (var k = 0; k < ticks.length; k++) {
          _loop(k);
        }
      }

      var hover = options.hover || false; // draw a dashed line when someone hovers over a data point

      if (hover && lineChartUtils.isTooltipActive()) {
        var activePoint = lineChartUtils.tooltip._active[0];
        var x = activePoint.tooltipPosition().x;
        var maxY = 1;
        var borderWidth = 0;
        datasets.forEach(function (set) {
          // get maximum Y value
          // get borderWidth of that dataset
          var point = lineChartUtils.getPointFromDataset(set, activePoint);

          var _lineChartUtils$getPo = lineChartUtils.getPointMetrics(set, point, [maxY, borderWidth]);

          var _lineChartUtils$getPo2 = _slicedToArray(_lineChartUtils$getPo, 2);

          maxY = _lineChartUtils$getPo2[0];
          borderWidth = _lineChartUtils$getPo2[1];
        }); // calculate the height of the line.
        // see function above in comment block.

        var highestDataY = lineChartUtils.calculateHighestDataY([bottomY, topY, maxY, tickMax, tickLow, borderWidth]); // if the calculated point has become too high it will extend below the chart

        lineChartUtils.isPointTooHigh(highestDataY, bottomY, tickLow); // draw line
        // save the context, destroy the canvas, draw a new line,
        // set the line settings (stroke) and then restore the canvas

        optionsHandler.drawLineHeightAnnotation(x, bottomY, highestDataY);
      }
    }
  }; // if the environment is neither amd nor commonjs, register the plugin globally for the samples and tests

  if (!(typeof define === "function" && define.amd) && !((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports)) {
    Chart.pluginService.register(plugin);
  }

  exports.AnnotationRenderer = AnnotationRenderer;
  exports.LineChartUtils = LineChartUtils;
  exports.default = plugin;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
